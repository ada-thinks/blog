---
author: Ada
date: '2022-11-08'
---

## 适用于小规模数据

### 冒泡排序 - 每一轮，通过比较值把最大/最小的值移到最后

```javascript
function bubbleSort(arr) {
    // 先判断临界条件
    if (arr == null || arr.length < 2) return;
    let n = arr.length;
    // 遍历所有数组元素
    for (let i = 0; i < n - 1; i++) {
        // 添加一个标志位 flag，用于记录本轮是否有元素发生交换
        let flag = false;
        // 最后i个元素已经排好序，无需再次比较
        for (let j = 0; j < n - 1 - i; j++) {
            // 如果当前元素大于下一个元素，则交换
            if (arr[j] > arr[j + 1]) {
                // 交换 arr[j] 和 arr[j + 1]
                [ arr[j], arr[j+1] ] = [ arr[j+1], arr[j] ];
                // 设置 flag 为 true，表示发生了交换
                flag = true;
            }
        }
        // 如果在这一轮中没有发生交换，说明数组已经是有序的，直接退出循环
        if (!flag) {
            break;
        }
    }
    return arr;
}
```

### 选择排序

每一轮，记录最小/最大的值的下标，交换位置
不稳定

```javascript
function selectionSort(arr) {
  // 先判断临界条件
  if (arr == null || arr.length < 2) return;
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    let midIndex = i;
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[midIndex]) {
        minIndex = j; // 记录最小值的下标
      }
    }
    // 用es6的解构方式，交换两值swap(arr,i,minIndex)
    [arr[i], arr[minIdex]] = [arr[minIdex], arr[i]];
  }
  return arr;
}
```

### 插入排序

类似于玩纸牌，每一轮，抽取一张，在已有序的牌面中从后往前，找合适的位置插入

```javascript
function insertionSort(arr) {
  // 判断临界情况
  if (arr == null || arr.length < 2) return arr;
  let len = arr.length;
  // 0-0有序的
  // 1-i 想有序的
  for (let i = 1; i < len; i++) {
    for (let j = i - 1; j >= 0; j--) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}
```

tips: 关于上面的算法，大部分都用到了两值交换，以下常用的有这几种方法

- ES6 的解构赋值

```javascript
[a, b] = [b, a];
```

- 异或运算（同为 0，异为 1，可理解为无进位相加） 利用 a ^ b ^ b = a 的特点，(前提：a,b 指向的地址不一样)进行数值交换

```javascript
let a = 1,
  b = 2;
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

- 借用中间数 temp

```javascript
temp = a;
a = b;
b = temp;
```

## 适用于大规模数据

### 快速排序（二叉树的前序遍历-根左右）

取数组中间的值 mid 出来作比较，<mid 放左区间 mid< 放右区间 ,再 concat 连接起来，如此循环
时间复杂度 O(nlogn) ,空间复杂度 O(logn),不稳定

```javascript
function jsQuickSort(arr) {
  // 临界条件
  if (arr == null || arr.length < 2) return;

  const midIndex = l + ((r - l) >> 1);
  // 从数组中取出我们的"基准"元素  splice的目的是将取"中心"元素的值之后将原数组中该值删除，
  // 这样下面的for循环的时候是不会循环中心元素了
  const mid = arr.splice(midIndex, 1)[0];
  const left = [], right = [];
  arr.forEach((item) => {
    item < mid ? left.push(item) : right.push(item);
  });
  //至此，我们将数组分成了left和right两个部分
  return jsQuickSort(left).concat(mid, jsQuickSort(right)); //分而治之
}
```

### 归并排序（二叉树的后序遍历-左右根）

- 1.分解：将数组分成两半。
- 2.递归排序：递归地对每半部分进行归并排序。
- 3.合并：将两个有序的子数组合并成一个有序的数组。
时间复杂度 O(nlogn) ,空间复杂度 O(n) 稳定

```javascript
function mergeSort(arr) {
    if (arr.length < 2) {
        return arr;
    }
    // 1.分解：将数组分成两半。
    const middle = arr.length >> 1;
    const left = arr.slice(0, middle);
    const right = arr.slice(middle);
    // 3.合并：将两个有序的子数组合并成一个有序的数组。
    return merge(mergeSort(left), mergeSort(right));
}
 // 2.递归排序：递归地对每半部分进行归并排序。

//  merge 函数：

// 初始化一个空数组 result 用于存储合并后的结果。
// 使用两个指针 i 和 j 分别指向左右数组的起始位置。
// 比较左右数组的元素，将较小的元素放入 result 并移动相应的指针。
// 当其中一个数组遍历完后，将另一个数组剩余的部分直接追加到 result 中。
function merge(left, right) {
    let result = [];
    let i = 0;
    let j = 0;

    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) {
            result.push(left[i]);
            i++;
        } else {
            result.push(right[j]);
            j++;
        }
    }

     // 合并剩余元素
    // 将 left 数组中未合并的部分添加到 result
    // 将 right 数组中未合并的部分添加到 result
    return result.concat([...left.slice(i),...right.slice(j)]);
}
```

拓展问题：
![avatar](./asset/20221113-01.png)

解答：
小和问题等价于找数组中每一个元素右侧有几个比当前数大的元素
通过归并的思想，先分解，再 merge。分解至单个元素，在合并的过程中记录每个元素右侧大于当前元素的个数
注意：当左右相等的时候，一定先拷贝右组的数，且不产生小和，因为不知道右组有多少数比左组的数大

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var reversePairs = function (nums) {
  // 问题等价-找右边比它小的数
  if (nums == null || nums.length < 2) return 0;

  // 小和问题：不用这一步；逆序问题： 需要反转数组，前边大于后边的解法，变成 前边小于后边的解法
  nums.reverse(); // 这是重要的一步

  return process(nums, 0, nums.length - 1);
};

function process(arr, l, r) {
  // base case
  if (l == r) {
    return 0;
  }
  let mid = l + ((r - l) >> 1);
  return (
    process(arr, l, mid) + process(arr, mid + 1, r) + merge(arr, l, mid, r)
  );
}

function merge(arr, l, mid, r) {
  // 申请空间用于外排序
  let temp = new arr(r - l + 1);

  let i = 0,
    p1 = l,
    p2 = mid + 1,
    res = 0;

  while (p1 <= mid && p2 <= r) {
    // 这里处理逆序对
    res += arr[p1] < arr[p2] ? r - p2 + 1 : 0;
    temp[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
  }
  while (p1 <= mid) {
    temp[i++] = arr[p1++];
  }
  while (p2 <= r) {
    temp[i++] = arr[p2++];
  }
  for (let i = 0; i < temp.length; i++) {
    arr[l + i] = temp[i];
  }
  return res;
}
```

## 工程优化

在大规模中使用 快排或者归并，然后判断需排序的个数，如果<60,就使用小规模的排序，这样综合排序会更好，其它方面就从稳定性（值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变）去考虑

![avatar](./asset/20221113-02.png)

